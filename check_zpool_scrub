#! /bin/sh

# MIT License
#
# Copyright (c) 2016 Josef Friedrich <josef@friedrich.rocks>
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

OS=$(uname)

########################################################################
# Date functions
########################################################################

# to_year ###

##
# Get the four digit year integer from now.
#
# Return:
#   The current 4 digit year.
##
_now_to_year() {
	date +%Y
}

##
# Convert a date in the format YYYY-MM-DD to a four digit year integer.
#
# Parameters:
#   a date in the format YYYY-MM-DD
#
# Return:
#   four digit year integer
##
_date_to_year() {
	local OPTIONS
	if [ "$OS" = 'Linux' ]; then
		OPTIONS="--date $1"
	# FreeBSD, Darwin
	else
		OPTIONS="-j -f %Y-%m-%d $1"
	fi
	date $OPTIONS +%Y
}

# to_datetime ###

##
# Convert a UNIX timestamp to a datetime string.
#
# Parameters:
#   UNIX timestamp
#
# Return:
#   %Y-%m-%d.%H:%M:%S
##
_timestamp_to_datetime() {
	local OPTIONS
	if [ "$OS" = 'Linux' ]; then
		OPTIONS="--date @$1"
	# FreeBSD, Darwin
	else
		OPTIONS="-j -f %s $1"
	fi
	date $OPTIONS +%Y-%m-%d.%H:%M:%S
}

# to_timestamp ###

##
# Get the current UNIX timestamp.
#
# Return:
#   %current UNIX timestamp
##
_now_to_timestamp() {
	date +%s
}

##
# Convert a datetime in the ctime format to a Unix timestamp.
# ctime is a textual representation of a datetime derived from the
# c function ctime (https://en.cppreference.com/w/c/chrono/ctime).
# The ctime string has the following format:  Www Mmm dd hh:mm:ss yyyy,
# where Www is the weekday, Mmm the month in letters, dd the day of the
# month, hh:mm:ss the time, and yyyy the year.
#
# see https://www.freebsd.org/cgi/man.cgi?query=strftime&sektion=3
#  %c is replaced by national representation of time and date.
#
# Parameters:
#   $1: Www Mmm dd hh:mm:ss yyyy
#
# Return:
#   UNIX timestamp
##
_ctime_to_timestamp() {
	local OPTIONS
	if [ "$OS" = 'Linux' ]; then
		OPTIONS='--date'
	# FreeBSD, Darwin
	else
		OPTIONS='-j -f %c'
	fi
	date $OPTIONS "$1" +%s
}

PROJECT_PAGES='https://github.com/Josef-Friedrich/check_zpool_scrub
https://exchange.icinga.com/joseffriedrich/check_zpool_scrub
https://exchange.nagios.org/directory/Plugins/System-Metrics/File-System/check_zpool_scrub/details'

VERSION=1.1
FIRST_RELEASE=2016-09-08
SHORT_DESCRIPTION='Monitoring plugin to check how long ago the last ZFS scrub was performed.'
USAGE="check_zpool_scrub v$VERSION
Copyright (c) $(_date_to_year $FIRST_RELEASE)-$(_now_to_year) Josef Friedrich <josef@friedrich.rocks>

$SHORT_DESCRIPTION


Usage: check_zpool_scrub <options>

Options:
 -c, --critical=OPT_CRITICAL
    Interval in seconds for critical state.
 -p,--pool=OPT_POOL
    Name of the pool
 -h, --help
    Show this help.
 -s, --short-description
    Show a short description / summary.
 -v, --version
    Show the version number.
 -w, --warning=OPT_WARNING
    Interval in seconds for warning state. Must be lower than -c.

Performance data:
 - last_ago
    Time interval in seconds for last scrub.
 - warning
    Interval in seconds.
 - critical
    Interval in seconds.
 - progress
    Percent 0 - 100
 - speed
    MB per second
 - time
    Time to go in minutes

Details about the implementation of this monitoring plugin:

This monitoring plugin grabs the last scrub date from the command
'zpool status POOL'.
"

_getopts() {
	while getopts ':c:hp:svw:-:' OPT ; do
		case $OPT in
			c) OPT_CRITICAL=$OPTARG ;;
			h) echo "$USAGE" ; exit 0 ;;
			p) OPT_POOL="$OPTARG" ;;
			s) echo "$SHORT_DESCRIPTION" ; exit 0 ;;
			v) echo "$VERSION" ; exit 0 ;;
			w) OPT_WARNING=$OPTARG ;;

			\?)
				echo "Invalid option “-$OPTARG”!" >&2
				exit 2
				;;

			:)
				echo "Option “-$OPTARG” requires an argument!" >&2
				exit 3
				;;

			-)
				LONG_OPTARG="${OPTARG#*=}"

				case $OPTARG in

					critical=?*)
						OPT_CRITICAL=$LONG_OPTARG
						;;

					help)
						echo "$USAGE"
						exit 0
						;;

					pool=?*)
						OPT_POOL="$LONG_OPTARG"
						;;

					short-description)
						echo "$SHORT_DESCRIPTION"
						exit 0
						;;

					version)  echo "$VERSION" ; exit 0 ;;

					warning=?*)
						OPT_WARNING=$LONG_OPTARG
						;;

					help*|short-description*|version*)
						echo "No argument allowed for the option “--$OPTARG”!" >&2
						exit 4
						;;

					critical*|pool*|warning*)
						echo "Option “--$OPTARG” requires an argument!" >&2
						exit 3
						;;

					'')	# "--" terminates argument processing
						break
						;;

					*)
						echo "Invalid option “--$OPTARG”!" >&2
						exit 2
						;;

				esac
				;;

		esac
	done
}

# Exit codes
STATE_OK=0
STATE_WARNING=1
STATE_CRITICAL=2
STATE_UNKNOWN=3

########################################################################
# Detect the date of the last scrub.
#
# Grab the date string of the last scrub from "zpool status". If the
# last scrub was canceled than grab the last scrub date from "zpool
# history". On old pool with a lot of history grabing only from "zpool
# history" is very slow.
########################################################################

# Functions:

# _last_scrub_grab_ctime_from_string
# _last_scrub_grab_ctime_from_command
# _last_scrub_to_timestamp
# _get_last_scrub_timestamp

##
# /* If there's never been a scan, there's not much to say. */
#   "none requested\n"
#     -> scan: none requested
#
# /* Scan is finished or canceled. */
#   "scrub repaired %s in %lluh%um with %llu errors on %s"
#      -> scan: scrub repaired 0 in 0h0m with 0 errors on Mon Aug  6 16:30:52 2018
#
#   "resilvered %s in %lluh%um with %llu errors on %s"
#
#   "scrub canceled on %s"
#
#   "resilver canceled on %s"
#
# /* Scan is in progress. */
#
#   "scrub in progress since %s"
#
#   "resilver in progress since %s"
#
# Parameters:
#   $1: The output of "zpool status POOL"
#
# Return:
#   A datetime formated in ctime format.
##
_last_scrub_grab_ctime_from_string() {
	# Www Mmm dd hh:mm:ss yyyy,
	local REGEX
	REGEX="\
s/\
^.*\
(canceled on|in progress since|errors on)\
 \
(.*)$\
/\2/p"
	echo "$1" | \
		grep '  scan: ' | \
		sed -n -E "$REGEX"
}

##
# Parameters:
#   $1: The name of the pool.
##
_last_scrub_grab_ctime_from_command() {
	_last_scrub_grab_ctime_from_string "$(zpool status "$1" )"
}

##
# Parameters:
#   $1: The name of the pool.
##
_last_scrub_to_timestamp() {
	local CTIME
	CTIME="$(_last_scrub_grab_ctime_from_command "$1")"
	if [ -n "$CTIME" ]; then
		_ctime_to_timestamp "$CTIME"
	fi
}

##
# Assemble the performace data
##
_performance_data() {
	echo "| \
last_ago=$DIFF \
warning=$OPT_WARNING \
critical=$OPT_CRITICAL \
progress=$PROGRESS \
speed=$SPEED \
time=$TIME"
}

########################################################################
# progress
########################################################################

##
# Grab the scrub progress from zpool status
#
# Parameters:
#   $1: The name of the pool
#
# Return:
#   A progress string (85,3%)
##
_progress_grep() {
	zpool status "$1" | \
		grep -E -o '[[:digit:],]*%'
}

_progress_normalize() {
	echo $1 | \
		sed 's/%//' | \
		tr ',' '.'
}

_progress() {
	local GREP
	GREP="$(_progress_grep "$1")"
	if [ -n "$GREP" ]; then
		_progress_normalize "$GREP"
	else
		echo 100
	fi
}

########################################################################
# Speed
########################################################################

_speed_grep() {
	zpool status "$1" | \
		grep -E -o '[[:digit:],]*[[:alpha:]]*/s'
}

_speed_normalize() {
	local SPEED UNIT
	SPEED=$(echo "$1" | sed 's#/s##' | tr , .)
	UNIT=$(echo -n "$SPEED" | tail -c  1)
	SPEED=$(echo "$SPEED" | sed 's/.$//' )

	if [ "$UNIT" = K ]; then
		SPEED="$(echo "$SPEED" | awk '{MB = $1 / 1024 ; print MB}')"
	fi
	echo $SPEED
}

_speed() {
	local SPEED
	SPEED="$(_speed_grep "$1")"
	if [ -n "$SPEED" ]; then
		_speed_normalize "$SPEED"
	else
		echo 0
	fi
}

########################################################################
# Time to go
########################################################################

##
# Extract the time to go from the zpool status output.
#
# Parameters:
# $1: POOL: Name of the pool
#
# Responsible for the output is this line:
#   (void) printf(gettext(", %lluh%um to go\n"),
# in the ZFS source code.
# https://github.com/openzfs/openzfs/blob/ed81aacb0d0fcbf7e0c0745ea4556655050c26bf/usr/src/cmd/zpool/zpool_main.c#L4441
#
# For example:
# Input:
#   ...
#   scan: scrub in progress since Sun Aug 13 00:24:02 2017
#     7,34T scanned out of 10,1T at 57,4M/s, 14h12m to go
#     0 repaired, 72,38% done
#   ...
# Output:
#     14h12m
#
# Other solutions:
#
# Not working on FreeBSD:
#   grep -P -o '(?<=, )[[:digit:]]*h[[:digit:]]*m(?= to go)'
#
# Naive solution:
#   grep ' to go' |
#   awk '{ print $8 }'
##
_time_grep() {
	zpool status "$1" | \
		grep ' to go' |
		sed -E 's/^.*, (.*h.*m) to go.*$/\1/g'
}

_time_to_min() {
	local HOURS MIN
	HOURS=$(echo "$1" | sed 's/h.*//')
	MIN=$(echo "$1" | sed 's/.*h//' | sed 's/m//')
	echo $((HOURS * 60 + MIN))
}

_time() {
	local GREP
	GREP="$(_time_grep "$1")"
	if [ -n "$GREP" ]; then
		_time_to_min "$GREP"
	else
		echo 0
	fi
}

## This SEPARATOR is required for test purposes. Please don’t remove! ##

_getopts $@

if [ -z "$OPT_WARNING" ]; then
	# 1 month 60*60*24*31
	OPT_WARNING=2678400
fi

if [ -z "$OPT_CRITICAL" ]; then
	# 2 month 60*60*24*31*2
	OPT_CRITICAL=5356800
fi

if ! zpool status "$OPT_POOL" > /dev/null 2>&1; then
	echo "“$OPT_POOL” is no ZFS pool!" >&2
	echo "$USAGE" >&2
	exit $STATE_UNKNOWN
fi

NOW=$(_now_to_timestamp)
LAST_SCRUB=$(_last_scrub_to_timestamp "$OPT_POOL")
DIFF=$((NOW - LAST_SCRUB))

if [ "$OPT_WARNING" -gt "$OPT_CRITICAL" ]; then
	echo '<warntime> must be smaller than <crittime>' >&2
	_usage  >&2
	exit $STATE_UNKNOWN
fi

# OPT_POOL: The name of the ZFS pool.
PROGRESS=$(_progress "$OPT_POOL")
SPEED="$(_speed "$OPT_POOL")"
TIME="$(_time "$OPT_POOL")"

RETURN=STATE_UNKNOWN

if [ "$DIFF" -gt "$OPT_CRITICAL" ]; then
	RETURN=$STATE_CRITICAL
	MESSAGE="CRITICAL:"
elif [ "$DIFF" -gt "$OPT_WARNING" ]; then
	RETURN=$STATE_WARNING
	MESSAGE="WARNING:"
else
	RETURN=$STATE_OK
	MESSAGE="OK:"
fi

if [ $LAST_SCRUB = -1 ]; then
	RETURN=$STATE_UNKNOWN
	echo "UNKNOWN: Failed to run zpool history"
else
	echo "$MESSAGE The last scrub on zpool “${OPT_POOL}” was performed on $(_timestamp_to_datetime $LAST_SCRUB) $(_performance_data)"
fi

exit $RETURN
